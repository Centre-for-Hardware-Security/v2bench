#include <iostream> 
#include <fstream>
#include <string>
#include <vector>
#include <regex>

using namespace std;

void parseVerilog();
void writeBench();
string is_a_gate (string word);
bool is_output_pin (string pin);
void remove_clock_pins();

struct gate {
	string type;
	string id;
	vector <string> pins;
	vector <string> nets;
};

// some globals
vector <string> inputs;
vector <string> outputs;
vector <gate> gates;

string netlist;
string bench;

#include "cell_definition.h" // this includes the strings for the gates of the library


int main(int argc, char** argv) 
{ 
	if (argc != 3) {
		cout << "wrong number of parameters" << std::endl;
		cout << "the correct usage is " << argv[0] << " input.v output.bench" << std::endl;
		return 0;
	}

	netlist = argv[1];
	bench = argv[2];
	

	parseVerilog();
	remove_clock_pins();
	writeBench();
	return 0; 
}


void parseVerilog() {
	std::ifstream file(netlist);
	if (!file) {
		std::cout << "error opening file" << netlist << std::endl;
		return;
	}
	else {
		cout << "reading " << netlist << " ..." << endl;
	}

	string word, temp1, temp2;
	regex reg1(",|\\(|\\)");
	regex reg2(",");
	regex reg3(",|\\(|\\)|\\s");

	int i = 0;

	while(file >> word) {
		if (word == "module") {
			bool first = true;
			while (1) {
				file >> temp1; // gets next string, possibly a mess with commas and parentheses

				sregex_token_iterator iter(temp1.begin(), temp1.end(), reg1, -1);
				sregex_token_iterator end;
				
				vector<string> vec(iter, end);
				bool willbreak = false;
				
				for (auto a : vec) {
					if (first) {
						cout << "found module: " << a << endl;
						first = false;
					}
					if (a == ";") {
						willbreak = true;
					}
				}
				if (willbreak)	{
					break; // the inner loop is done, we read the interface
				}
			}
		}
		else if (word == "input") {
			while (1) {
				file >> temp1; // gets next string, possibly a mess with commas

				sregex_token_iterator iter(temp1.begin(), temp1.end(), reg2, -1);
				sregex_token_iterator end;
				
				vector<string> vec(iter, end);
				bool willbreak = false;
				for (auto a : vec) {
					if (a.find(';') != std::string::npos ) {
						willbreak = true; // ; found, the inner loop is done, we read a list of inputs
						a.pop_back();
						// TODO: remove last charater
					}
					inputs.push_back(a);
					cout << "input found: " << a << endl;

				}
				if (willbreak) break;
			}
		}
		else if (word == "output") {
			while (1) {
				file >> temp1; // gets next string, possibly a mess with commas

				sregex_token_iterator iter(temp1.begin(), temp1.end(), reg2, -1);
				sregex_token_iterator end;
				
				vector<string> vec(iter, end);
				bool willbreak = false;
				for (auto a : vec) {
					if (a.find(';') != std::string::npos ) {
						willbreak = true; // ; found, the inner loop is done, we read a list of inputs
						a.pop_back();
					}
					outputs.push_back(a);
					cout << "output found " << a << endl;
				}
				if (willbreak) break;
			}
		}
		else if (word == "wire") {
			// ignore?
		}
		else { // possibly a gate!
			string type = is_a_gate(word);
			if (type != "") {
				gate gate;
				bool first = true;
				while (1) {
					file >> temp1; // gets next string, possibly a mess with commas and parentheses

					sregex_token_iterator iter(temp1.begin(), temp1.end(), reg3, -1);
					sregex_token_iterator end;
					
					vector<string> vec(iter, end);
					bool willbreak = false;
					
					for (auto a : vec) {
						if (a=="") continue; // happens when tokenizing spaces follows by commas ...
						if (a == ";") {
							willbreak = true;
							break; // will break the for loop
						}

						cout << "parsing " << a << endl;
						if (first) {
							cout << "gate found " << word << ": " << a << endl;
							first = false;
							gate.type = type;
							gate.id = a;
							continue;					
						}
						if (a[0] == '.') { // pin
							//cout << "... pin found: " << a << endl;
							gate.pins.push_back(a);
						}
						else { // if it is not a pin, then it is a connection
							//cout << "... net found: " << a << endl;
							gate.nets.push_back(a);
						}
					}
					if (willbreak)	{
						break; // the inner loop is done, we read the interface
					}
				}
				gates.push_back(gate);
				//cout << gate.nets.size() << " " << gate.pins.size() << endl;
			}
		}
	}

}

void writeBench() {
	ofstream benchf (bench.c_str());

	if (!benchf.is_open()) {
		cout << "problem opening " << bench << endl;
	}

	//benchf << "#generated by silly converter" << endl; // comments break some tools... sigh

	for (auto a : inputs) {
		benchf << "INPUT(" << a << ")" << endl;
	}

	benchf << endl; // empty line before we start doing outputs

	for (auto a : outputs) {
		benchf << "OUTPUT(" << a << ")" << endl;
	}

	for (auto a : gates) {
		stringstream builder;

		auto itA = a.pins.begin();
		auto itB = a.nets.begin();		
		while(itA != a.pins.end() || itB != a.nets.end()) {
			if (is_output_pin(*itA)) { // typical output pins
				builder << *itB << " = ";
			}
			++itA;
			++itB;
			
		}
			
		builder << a.type << "(";

		itA = a.pins.begin(); // reset iterators
		itB = a.nets.begin();	
	
		while(itA != a.pins.end() || itB != a.nets.end()) {
			if (!is_output_pin(*itA)) { // typical output pins
				builder << *itB << ", ";
			}
			++itA;
			++itB;
			
		}

		string builder2(builder.str());
		builder2.pop_back();
		builder2.pop_back();
		benchf << builder2 << ")" << endl;

	}
}

string is_a_gate (const string word) {
	if (word == DFF) return "DFF";
	if (word == INV) return "NOT";
	if (word == AND) return "AND";
	if (word == OR) return "OR";
	if (word == NAND) return "NAND";
	if (word == NOR) return "NOR";

	return "";
}

bool is_output_pin (string pin) {
	if (pin == ".Z") return true;
	if (pin == ".ZN") return true;
	if (pin == ".Q") return true;


	return false;
}

void remove_clock_pins() {
	auto gate_iter = gates.begin();
	for (; gate_iter != gates.end();gate_iter++) {
		auto itA = gate_iter->pins.begin();
		auto itB = gate_iter->nets.begin();		
		while(itA != gate_iter->pins.end() || itB != gate_iter->nets.end()) {
			if (*itA == ".CP") { // typical clock pin in TSMC libs
				//cout << "found clock pin on gate " << gate_iter->id << endl;
				itA = gate_iter->pins.erase(itA);
				itB = gate_iter->nets.erase(itB);
			}
			else {
				++itA;
				++itB;
			}
		}
	}
}


